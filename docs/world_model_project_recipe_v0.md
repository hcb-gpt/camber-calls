# How to Add a New Project to the World Model (v0)

**Status:** Operator runbook
**Date:** 2026-02-16
**Worked example:** Moss Residence
**Prerequisite reading:** `docs/world_model_architecture_v0.md`

---

## 1. Prerequisites

Before you start, collect three things:

| Item | Where to get it | Moss example |
|------|-----------------|--------------|
| **project_id** (UUID) | `SELECT id FROM public.projects WHERE name ILIKE '%moss%';` | *(query your DB)* |
| **Plan date** (effective time) | Cover sheet of construction plans, permit application, or contract date | The date Moss plans were issued (use UTC midnight, e.g. `2026-01-15T04:00:00Z`) |
| **Field extract** (JSON) | Manual extraction from plans/specs, or an LLM-assisted parse reviewed by operator | `gandalf_project_MOSS_fields_values.json` |

The field extract should cover: dimensions, materials, features, contacts, and site data that are **not already on the `projects` table**. Static registry fields (address, city, state, zip, county, permit_jurisdiction) belong on `projects` directly -- do not duplicate them as facts.

### What belongs on `projects` vs `project_facts`

| Surface | Use for | Examples |
|---------|---------|----------|
| `projects` row | Static registry / identity fields | name, aliases, street, city, state, zip, county, permit_jurisdiction, job_type, status |
| `project_facts` | Time-varying scope, features, dimensions, contacts, site details that may change or that the LLM needs for disambiguation | sqft, room counts, materials, roof pitches, foundation type, plan designer contact |

Rule of thumb: if it changes over the life of the project or helps the AI router distinguish this project from others, it is a fact.

---

## 2. Fact Taxonomy

Use these `fact_kind` values. Each maps to a payload shape.

### 2.1 `scope.feature`

General-purpose scope fact. Use for boolean features, named attributes, and configuration details.

```json
{
  "feature": "feature.motorized_screens",
  "value": true,
  "tags": ["PLANS_GT"],
  "confidence": 0.95
}
```

Moss examples of `scope.feature`:
- `feature=building.floors_count, value=2`
- `feature=building.bedrooms_count, value=4`
- `feature=building.fireplaces_count, value=1`
- `feature=foundation.type, value="Crawlspace (block)"`
- `feature=construction.primary, value="Frame"`
- `feature=garage.ceiling_height, value="11'6\""`

### 2.2 `scope.dimension`

Numeric measurements with units.

```json
{
  "feature": "sqft.heated_total",
  "value": 4213,
  "unit": "sqft",
  "tags": ["PLANS_GT"],
  "confidence": 0.98
}
```

Moss examples of `scope.dimension`:
- `feature=sqft.heated_total, value=4213, unit=sqft`
- `feature=sqft.heated_main, value=2928, unit=sqft`
- `feature=sqft.heated_upper, value=1285, unit=sqft`
- `feature=sqft.garage_attached_unheated, value=640, unit=sqft`
- `feature=sqft.porch_stoop, value=554, unit=sqft`
- `feature=sqft.patio, value=152, unit=sqft`
- `feature=sqft.under_roof_total_est, value=5407, unit=sqft`
- `feature=garage.floor_below_main, value=18, unit=inches`

### 2.3 `scope.material`

Material specifications.

```json
{
  "feature": "roof.material.porch",
  "value": "Metal",
  "tags": ["PLANS_GT"],
  "confidence": 0.90
}
```

Moss examples of `scope.material`:
- `feature=roof.material.porch, value="Metal"`
- `feature=construction.secondary, value="Brick elements shown in elevations/wall detail"`
- `feature=foundation.wall, value="8\" concrete block"`

### 2.4 `scope.contact`

Project-associated contacts (designers, engineers, consultants) that are not vendors/trades.

```json
{
  "feature": "plan_designer",
  "value": "McKenzie Drafting – Custom Home Design",
  "phone": "706-759-2146",
  "email": "mckenziedrafting@windstream.net",
  "tags": ["PLANS_GT"],
  "confidence": 0.95
}
```

### 2.5 `scope.site`

Site-specific details not covered by `projects` table fields.

```json
{
  "feature": "roof.pitch.main",
  "value": "6/12",
  "tags": ["PLANS_GT"],
  "confidence": 0.90
}
```

Moss examples of `scope.site`:
- `feature=roof.pitch.main, value="6/12"`
- `feature=roof.pitch.gables, value="10/12"`
- `feature=roof.pitch.transitions, value="3.75/12"`
- `feature=roof.pitch.porch_metal, value="1.75/12"`
- `feature=permit.application_fee, value=100, unit="USD"`

---

## 3. Provenance Rules

Every fact must have provenance. For plan-seeded facts, the rules are:

| Field | Value | Rationale |
|-------|-------|-----------|
| `as_of_at` | Plan issue date (UTC) | Effective time -- when the fact became true |
| `observed_at` | `now()` at seed time | System time -- when we recorded it |
| `evidence_event_id` | Auto-generated by the seed script | Points to a `manual` evidence_events row |

The seed script creates a single `evidence_events` row with:
- `source_type = 'manual'`
- `source_id = 'manual_seed:project_facts_v0:<random_hex>'`
- `occurred_at_utc = as_of_at`
- `metadata` containing the seed script name and notes

This gives every seeded fact a traceable provenance chain. All facts from a single seed run share one evidence_event_id, which makes auditing straightforward.

### Tags convention

- `PLANS_GT` -- fact extracted from construction plans (ground truth quality)
- `ALIAS` -- fact is a name/alias used for project matching
- Additional tags as needed for the source type

---

## 4. Seed SQL Pattern

Copy the template from `scripts/backfills/project_facts_seed_pilot_v0.sql` and adapt it.

### Step-by-step

**Step 1: Set params.** Replace the placeholder UUID and date:

```sql
with params as (
  select
    '<YOUR_PROJECT_UUID>'::uuid as project_id,
    '<PLAN_DATE_UTC>'::timestamptz as as_of_at,
    now()::timestamptz as observed_at,
    ('manual_seed:project_facts_v0:' || encode(gen_random_bytes(8), 'hex'))::text as source_id
),
```

For Moss Residence, this would be:

```sql
with params as (
  select
    '<MOSS_PROJECT_UUID>'::uuid as project_id,
    '2026-01-15T04:00:00Z'::timestamptz as as_of_at,  -- plan issue date
    now()::timestamptz as observed_at,
    ('manual_seed:project_facts_v0:' || encode(gen_random_bytes(8), 'hex'))::text as source_id
),
```

**Step 2: Write the manual_evidence CTE.** This is unchanged from the template -- it creates one evidence_events row per seed run.

**Step 3: Build the seed_facts CTE.** Add one `UNION ALL SELECT` per fact. Map your field extract to the taxonomy from Section 2.

Moss example (abbreviated):

```sql
seed_facts as (
  -- Dimensions
  select 'scope.dimension'::text as fact_kind,
    jsonb_build_object('feature','sqft.heated_total','value',4213,'unit','sqft',
      'tags',jsonb_build_array('PLANS_GT'),'confidence',0.98) as fact_payload
  union all select 'scope.dimension',
    jsonb_build_object('feature','sqft.heated_main','value',2928,'unit','sqft',
      'tags',jsonb_build_array('PLANS_GT'),'confidence',0.98)
  union all select 'scope.dimension',
    jsonb_build_object('feature','sqft.heated_upper','value',1285,'unit','sqft',
      'tags',jsonb_build_array('PLANS_GT'),'confidence',0.98)

  -- Features
  union all select 'scope.feature',
    jsonb_build_object('feature','building.floors_count','value',2,
      'tags',jsonb_build_array('PLANS_GT'),'confidence',0.98)
  union all select 'scope.feature',
    jsonb_build_object('feature','building.bedrooms_count','value',4,
      'tags',jsonb_build_array('PLANS_GT'),'confidence',0.98)
  union all select 'scope.feature',
    jsonb_build_object('feature','foundation.type','value','Crawlspace (block)',
      'tags',jsonb_build_array('PLANS_GT'),'confidence',0.95)

  -- Materials
  union all select 'scope.material',
    jsonb_build_object('feature','roof.material.porch','value','Metal',
      'tags',jsonb_build_array('PLANS_GT'),'confidence',0.90)

  -- Site
  union all select 'scope.site',
    jsonb_build_object('feature','roof.pitch.main','value','6/12',
      'tags',jsonb_build_array('PLANS_GT'),'confidence',0.90)

  -- Contact
  union all select 'scope.contact',
    jsonb_build_object('feature','plan_designer',
      'value','McKenzie Drafting – Custom Home Design',
      'phone','706-759-2146','email','mckenziedrafting@windstream.net',
      'tags',jsonb_build_array('PLANS_GT'),'confidence',0.95)
)
```

**Step 4: The INSERT and ROLLBACK.** The template's INSERT and final `rollback;` are unchanged. The script defaults to ROLLBACK so you can dry-run safely. Change to `commit;` only when you are ready to apply.

### Execution

```bash
# Dry run (ROLLBACK mode -- default)
psql "$DATABASE_URL" -f scripts/backfills/project_facts_seed_moss_v0.sql

# Apply (change last line to COMMIT first)
psql "$DATABASE_URL" -f scripts/backfills/project_facts_seed_moss_v0.sql
```

---

## 5. Verification

Run these proof queries after seeding (with `commit;`). All are safe read-only queries that can go through `scripts/query.sh`.

### 5.1 Seed counts by kind (did it land?)

```sql
-- scripts/sql/proofs/project_facts_seed_counts_by_kind.sql
-- Shows facts observed in the last 24 hours, grouped by kind
SELECT
  fact_kind,
  count(*) AS fact_count,
  count(*) FILTER (WHERE evidence_event_id IS NOT NULL) AS with_evidence,
  min(observed_at) AS min_observed_at,
  max(observed_at) AS max_observed_at
FROM public.project_facts
WHERE observed_at >= (now() - interval '24 hours')
GROUP BY fact_kind
ORDER BY fact_count DESC, fact_kind ASC;
```

**Expected for Moss:** rows for `scope.dimension`, `scope.feature`, `scope.material`, `scope.site`, `scope.contact` with `with_evidence = fact_count` for every row (100% provenance).

### 5.2 Provenance hygiene (no orphan facts)

```sql
SELECT count(*) AS orphan_facts
FROM public.project_facts
WHERE evidence_event_id IS NULL
  AND interaction_id IS NULL
  AND observed_at >= (now() - interval '24 hours');
```

**Expected:** `0`. Every seeded fact must have an evidence_event_id.

### 5.3 Project-specific spot check

```sql
SELECT
  fact_kind,
  fact_payload->>'feature' AS feature,
  fact_payload->>'value' AS value,
  evidence_event_id IS NOT NULL AS has_provenance,
  as_of_at,
  observed_at
FROM public.project_facts
WHERE project_id = '<MOSS_PROJECT_UUID>'
ORDER BY fact_kind, fact_payload->>'feature';
```

**Expected:** all rows from your seed, correct values, `has_provenance = true` on every row.

### 5.4 Evidence event integrity

```sql
SELECT
  e.evidence_event_id,
  e.source_type,
  e.source_id,
  e.occurred_at_utc,
  count(pf.*) AS fact_count
FROM public.evidence_events e
JOIN public.project_facts pf ON pf.evidence_event_id = e.evidence_event_id
WHERE e.source_id LIKE 'manual_seed:project_facts_v0:%'
  AND e.occurred_at_utc >= (now() - interval '7 days')
GROUP BY e.evidence_event_id, e.source_type, e.source_id, e.occurred_at_utc
ORDER BY e.occurred_at_utc DESC;
```

**Expected:** one evidence row per seed run, with `fact_count` matching the number of facts you inserted.

---

## 6. Activation (Enable Retrieval)

Seeded facts are inert until the ai-router reads them. Retrieval is gated by an environment variable.

### 6.1 Set the flag

In the ai-router Edge Function environment (Supabase Dashboard > Edge Functions > ai-router > Environment Variables, or via CLI):

```
WORLD_MODEL_FACTS_ENABLED=true
```

Optional tuning:

```
WORLD_MODEL_FACTS_MAX_PER_PROJECT=20   # default; max facts injected per candidate project
```

### 6.2 What the flag controls

When `WORLD_MODEL_FACTS_ENABLED=true`:
- ai-router fetches `project_facts` for each candidate project (KNOWN_AS_OF mode, same-call exclusion enforced)
- Facts are formatted into the LLM prompt as corroboration signals per candidate
- The model may output `world_model_references[]` citing facts that influenced its decision
- A guardrail layer checks for strong anchors and contradictions; weak-only or contradicted `assign` decisions are downgraded to `review`

When `false` (default): no facts are fetched or injected. Zero cost, zero risk.

### 6.3 Rollback

Set `WORLD_MODEL_FACTS_ENABLED=false` to disable retrieval instantly. Facts remain in the DB but are not read. No redeployment needed -- the flag is checked at runtime.

---

## 7. GT Validation (Measuring Impact)

After activation, measure whether world model facts improve attribution accuracy.

### 7.1 Before/after comparison

Run the GT evaluation harness on calls involving the seeded project. Compare:

| Metric | Without facts | With facts |
|--------|---------------|------------|
| Correct assign rate | baseline | measured |
| False assign rate | baseline | measured |
| Review-to-correct rate | baseline | measured |
| Downgrade rate (guardrail) | n/a | measured |

### 7.2 World model reference audit

```sql
SELECT
  sa.span_id,
  sa.decision,
  sa.project_id,
  sa.model_output->>'world_model_references' AS wm_refs,
  sa.confidence
FROM public.span_attributions sa
JOIN public.conversation_spans cs ON cs.id = sa.span_id
WHERE cs.interaction_id IN (
  -- calls involving the Moss project
  SELECT interaction_id FROM public.interactions
  WHERE project_id = '<MOSS_PROJECT_UUID>'
)
AND sa.attributed_at >= '<ACTIVATION_TIMESTAMP>'
ORDER BY sa.attributed_at DESC;
```

Check: are world_model_references present? Do they cite real facts? Did the guardrail fire appropriately?

### 7.3 Guardrail effectiveness

```sql
SELECT
  count(*) FILTER (WHERE (model_output->>'downgraded')::boolean = true) AS downgraded,
  count(*) FILTER (WHERE (model_output->>'strong_anchor_present')::boolean = true) AS strong_anchor,
  count(*) FILTER (WHERE (model_output->>'contradiction_found')::boolean = true) AS contradiction,
  count(*) AS total
FROM public.span_attributions
WHERE attributed_at >= '<ACTIVATION_TIMESTAMP>';
```

---

## Checklist (copy-paste for TRAM receipts)

```
[ ] project_id obtained
[ ] Plan date identified (as_of_at)
[ ] Field extract created and reviewed
[ ] Seed SQL written using template
[ ] Dry run (ROLLBACK) executed -- no errors
[ ] COMMIT run executed
[ ] Proof: seed_counts_by_kind -- all kinds present, 100% provenance
[ ] Proof: orphan_facts = 0
[ ] Proof: project spot check -- values correct
[ ] Proof: evidence_event integrity -- single evidence row, correct count
[ ] WORLD_MODEL_FACTS_ENABLED=true set on ai-router
[ ] GT validation baseline captured
[ ] Post-activation GT comparison run
```
